---
// AccentDice.astro - Interactive 3D dice that generate hex color codes
---

<div id="dice-canvas-container"></div>

<style>
	#dice-canvas-container {
		position: fixed;
		top: 2rem;
		right: 2rem;
		width: 200px;
		height: 120px;
		z-index: 1000;
		cursor: pointer;
		user-select: none;
	}

	#dice-canvas-container canvas {
		display: block;
		cursor: pointer;
	}

	@media (max-width: 768px) {
		#dice-canvas-container {
			top: 6rem;
			right: 1rem;
			width: 120px;
			height: 80px;
		}
	}
</style>

<script>
	import * as THREE from 'three';

	const HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
	let isRolling = false;
	let scene: THREE.Scene;
	let camera: THREE.PerspectiveCamera;
	let renderer: THREE.WebGLRenderer;
	let die1: THREE.Mesh;
	let die2: THREE.Mesh;
	let currentHexChars: string[] = [];

	function getRandomHexChar() {
		return HEX_CHARS[Math.floor(Math.random() * HEX_CHARS.length)];
	}

	function generateHexCode() {
		return Array.from({ length: 6 }, () => getRandomHexChar());
	}

	function createFaceTexture(chars: string): THREE.CanvasTexture {
		const canvas = document.createElement('canvas');
		canvas.width = 256;
		canvas.height = 256;
		const ctx = canvas.getContext('2d')!;

		// White background
		ctx.fillStyle = '#ffffff';
		ctx.fillRect(0, 0, 256, 256);

		// Black border
		ctx.strokeStyle = '#000000';
		ctx.lineWidth = 6;
		ctx.strokeRect(3, 3, 250, 250);

		// Black text - display all 3 characters
		ctx.fillStyle = '#000000';
		ctx.font = 'bold 70px monospace';
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		ctx.fillText(chars, 128, 128);

		const texture = new THREE.CanvasTexture(canvas);
		texture.needsUpdate = true;
		return texture;
	}

	function createDieMaterials(chars: string): THREE.MeshBasicMaterial[] {
		// Map all 3 characters to each face (front face will be the main one)
		// Order: right, left, top, bottom, front, back
		return [
			new THREE.MeshBasicMaterial({ map: createFaceTexture(chars) }), // right
			new THREE.MeshBasicMaterial({ map: createFaceTexture(chars) }), // left
			new THREE.MeshBasicMaterial({ map: createFaceTexture(chars) }), // top
			new THREE.MeshBasicMaterial({ map: createFaceTexture(chars) }), // bottom
			new THREE.MeshBasicMaterial({ map: createFaceTexture(chars) }), // front
			new THREE.MeshBasicMaterial({ map: createFaceTexture(chars) }), // back
		];
	}

	function createDie(x: number, chars: string): THREE.Mesh {
		const geometry = new THREE.BoxGeometry(1.10, 1.10, 1.10);
		const materials = createDieMaterials(chars);
		const die = new THREE.Mesh(geometry, materials);
		die.position.x = x;
		return die;
	}

	function updateDieFaces(die: THREE.Mesh, chars: string) {
		if (Array.isArray(die.material)) {
			die.material.forEach((mat) => {
				if (mat instanceof THREE.MeshBasicMaterial && mat.map) {
					mat.map = createFaceTexture(chars);
					mat.needsUpdate = true;
				}
			});
		}
	}

	function updateAccentColor(hexCode: string) {
		document.documentElement.style.setProperty('--accent', `#${hexCode}`);
		// Save to localStorage
		localStorage.setItem('accent-color', hexCode);
	}

	function loadSavedAccentColor(): string | null {
		return localStorage.getItem('accent-color');
	}

	function animateDiceRoll() {
		if (isRolling) return;
		isRolling = true;

		// Generate new hex code
		const newChars = generateHexCode();
		const die1Chars = newChars.slice(0, 3).join('');
		const die2Chars = newChars.slice(3, 6).join('');

		const startTime = Date.now();
		const duration = 600; // milliseconds
		const rotations = 2; // number of full rotations

		const die1StartRotation = { x: die1.rotation.x, y: die1.rotation.y, z: die1.rotation.z };
		const die2StartRotation = { x: die2.rotation.x, y: die2.rotation.y, z: die2.rotation.z };

		function animate() {
			const elapsed = Date.now() - startTime;
			const progress = Math.min(elapsed / duration, 1);
			const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic

			// Rotate dice
			die1.rotation.x = die1StartRotation.x + (Math.PI * 2 * rotations * eased);
			die1.rotation.y = die1StartRotation.y + (Math.PI * 2 * rotations * eased * 1.3);
			die1.rotation.z = die1StartRotation.z + (Math.PI * 2 * rotations * eased * 0.7);

			die2.rotation.x = die2StartRotation.x + (Math.PI * 2 * rotations * eased * 1.2);
			die2.rotation.y = die2StartRotation.y + (Math.PI * 2 * rotations * eased * 0.8);
			die2.rotation.z = die2StartRotation.z + (Math.PI * 2 * rotations * eased * 1.5);

			if (progress < 1) {
				requestAnimationFrame(animate);
			} else {
				// Animation complete - reset rotation to flat and update faces
				die1.rotation.set(0, 0, 0);
				die2.rotation.set(0, 0, 0);
				updateDieFaces(die1, die1Chars);
				updateDieFaces(die2, die2Chars);
				currentHexChars = newChars;
				updateAccentColor(newChars.join(''));
				isRolling = false;
			}
		}

		animate();
	}

	function onCanvasClick() {
		animateDiceRoll();
	}

	function init() {
		const container = document.getElementById('dice-canvas-container');
		if (!container) return;

		// Scene setup
		scene = new THREE.Scene();
		scene.background = null;

		// Camera setup
		camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
		camera.position.z = 4;

		// Renderer setup
		renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
		renderer.setSize(container.clientWidth, container.clientHeight);
		renderer.setClearColor(0x000000, 0);
		container.appendChild(renderer.domElement);

		// Initialize dice - check for saved color first
		const savedColor = loadSavedAccentColor();
		if (savedColor && savedColor.length === 6) {
			currentHexChars = savedColor.split('');
			// Apply saved color immediately
			updateAccentColor(savedColor);
		} else {
			currentHexChars = generateHexCode();
			// Apply initial random color
			updateAccentColor(currentHexChars.join(''));
		}

		const die1Chars = currentHexChars.slice(0, 3).join('');
		const die2Chars = currentHexChars.slice(3, 6).join('');

		// Create dice - no initial rotation, flat facing user
		die1 = createDie(-0.9, die1Chars);
		die2 = createDie(0.9, die2Chars);

		scene.add(die1);
		scene.add(die2);

		// Event listener - click anywhere on container
		container.addEventListener('click', onCanvasClick);

		// Handle window resize
		function onResize() {
			if (!container) return;
			camera.aspect = container.clientWidth / container.clientHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(container.clientWidth, container.clientHeight);
		}
		window.addEventListener('resize', onResize);

		// Animation loop
		function renderLoop() {
			requestAnimationFrame(renderLoop);
			renderer.render(scene, camera);
		}
		renderLoop();
	}

	// Initialize on load
	if (typeof window !== 'undefined') {
		init();
	}
</script>
